use cw2::set_contract_version;
use cosmwasm_std::*;
use crate::state::{AUCTION_COUNT, AUCTIONS, Auction, Bid, AuctionStatus, DEVELOPER_WALLET};
use crate::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};

const CONTRACT_NAME: &str = "crates.io:phoenix-escrow";
const CONTRACT_VERSION: &str = "1.0.0";

#[entry_point]
pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -> StdResult<Response> {
    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;
    AUCTION_COUNT.save(deps.storage, &0)?;
    Ok(Response::new()
        .add_attribute("method", "instantiate")
        .add_attribute("admin", msg.admin)
        .add_attribute("developer_wallet", DEVELOPER_WALLET))
}

#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> StdResult<Response> {
    match msg {
        ExecuteMsg::CreateAuction {
            item_id,
            description,
            metal_type,
            product_form,
            weight,
            weight_unit,
            purity_percent,
            brand,
            year,
            graded,
            grade,
            cert_number,
            starting_price,
            reserve_price,
            duration_hours,
        } => execute_create_auction(
            deps, env, info, 
            item_id, description, metal_type, product_form, weight, weight_unit,
            purity_percent, brand, year, graded, grade, cert_number,
            starting_price, reserve_price, duration_hours
        ),
        ),
        } => execute_create_auction(
            deps, env, info, 
            item_id, description, starting_price, 
            reserve_price, duration_hours
        ),
        ExecuteMsg::PlaceBid { auction_id, amount } => 
            execute_place_bid(deps, env, info, auction_id, amount),
        ExecuteMsg::EndAuction { auction_id } => 
            execute_end_auction(deps, env, info, auction_id),
        ExecuteMsg::ReleaseEscrow { auction_id } =>
            execute_release_escrow(deps, env, info, auction_id),
        ExecuteMsg::CancelAuction { auction_id } =>
            execute_cancel_auction(deps, env, info, auction_id),
    }
}

pub fn execute_create_auction(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    item_id: String,
    description: String,
    metal_type: MetalType,
    product_form: ProductForm,
    weight: u64,
    weight_unit: WeightUnit,
    purity_percent: u8,
    brand: Option<String>,
    year: Option<u16>,
    graded: bool,
    grade: Option<String>,
    cert_number: Option<String>,
    starting_price: Uint128,
    reserve_price: Option<Uint128>,
    duration_hours: u64,
) -> StdResult<Response> {
    // Validate inputs
    if starting_price.is_zero() {
        return Err(StdError::generic_err("Starting price must be > 0"));
    }
    
    if weight == 0 {
        return Err(StdError::generic_err("Weight must be > 0"));
    }
    
    if purity_percent == 0 || purity_percent > 100 {
        return Err(StdError::generic_err("Purity must be between 1-100%"));
    }
    
    // Validate graded items have grade and cert
    if graded {
        if grade.is_none() {
            return Err(StdError::generic_err("Graded items must have a grade"));
        }
        if cert_number.is_none() {
            return Err(StdError::generic_err("Graded items must have certificate number"));
        }
    }
    
    // Get next auction ID
    let auction_id = AUCTION_COUNT.update(deps.storage, |count| -> StdResult<_> {
        Ok(count + 1)
    })?;
    
    // Create comprehensive auction
    let auction = Auction {
        seller: info.sender.to_string(),
        item_id,
        description,
        metal_type: metal_type.clone(),
        product_form: product_form.clone(),
        weight,
        weight_unit: weight_unit.clone(),
        purity_percent,
        brand,
        year,
        graded,
        grade,
        cert_number,
        starting_price,
        reserve_price,
        start_time: env.block.time.seconds(),
        end_time: env.block.time.plus_seconds(duration_hours * 3600).seconds(),
        current_bid: None,
        bids: Vec::new(),
        status: AuctionStatus::Active,
        escrow_released: false,
    };
    
    // Save auction
    AUCTIONS.save(deps.storage, auction_id, &auction)?;
    
    // Index by metal type
    AUCTIONS_BY_METAL.save(deps.storage, (metal_type, auction_id), &auction_id)?;
    
    // Index by product form
    AUCTIONS_BY_FORM.save(deps.storage, (product_form, auction_id), &auction_id)?;
    
    // Return success with detailed attributes
    let mut response = Response::new()
        .add_attribute("action", "create_auction")
        .add_attribute("auction_id", auction_id.to_string())
        .add_attribute("seller", info.sender.to_string())
        .add_attribute("metal_type", format!("{:?}", metal_type))
        .add_attribute("product_form", format!("{:?}", product_form))
        .add_attribute("weight", weight.to_string())
        .add_attribute("weight_unit", format!("{:?}", weight_unit))
        .add_attribute("purity", format!("{}%", purity_percent))
        .add_attribute("graded", graded.to_string());
    
    if graded {
        response = response
            .add_attribute("grade", grade.unwrap())
            .add_attribute("certified", "true");
    }
    
    Ok(response)
}

pub fn execute_place_bid(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    auction_id: u64,
    amount: Uint128,
) -> StdResult<Response> {
    // Load auction
    let mut auction = AUCTIONS.load(deps.storage, auction_id)
        .map_err(|_| StdError::not_found("Auction"))?;
    
    // Validate auction is active
    if auction.status != AuctionStatus::Active {
        return Err(StdError::generic_err("Auction not active"));
    }
    
    // Check if auction hasn't ended
    if env.block.time.seconds() > auction.end_time {
        return Err(StdError::generic_err("Auction has ended"));
    }
    
    // Check if bid meets minimum
    let min_bid = match auction.current_bid {
        Some(ref current_bid) => current_bid.amount + Uint128::from(100u128), // 100 unit minimum increase
        None => auction.starting_price,
    };
    
    if amount < min_bid {
        return Err(StdError::generic_err(
            format!("Bid must be at least {}", min_bid)
        ));
    }
    
    // Create new bid
    let bid = Bid {
        bidder: info.sender.to_string(),
        amount,
        timestamp: env.block.time.seconds(),
    };
    
    // Update auction
    auction.current_bid = Some(bid.clone());
    auction.bids.push(bid);
    
    // Save updated auction
    AUCTIONS.save(deps.storage, auction_id, &auction)?;
    
    // Return success
    Ok(Response::new()
        .add_attribute("action", "place_bid")
        .add_attribute("auction_id", auction_id.to_string())
        .add_attribute("bidder", info.sender.to_string())
        .add_attribute("amount", amount.to_string()))
}

pub fn execute_end_auction(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    auction_id: u64,
) -> StdResult<Response> {
    // Load auction
    let mut auction = AUCTIONS.load(deps.storage, auction_id)
        .map_err(|_| StdError::not_found("Auction"))?;
    
    // Validate auction is active
    if auction.status != AuctionStatus::Active {
        return Err(StdError::generic_err("Auction already ended"));
    }
    
    // Check if sender is seller or auction has ended by time
    let is_seller = info.sender == auction.seller;
    let is_time_expired = env.block.time.seconds() > auction.end_time;
    
    if !is_seller && !is_time_expired {
        return Err(StdError::generic_err(
            "Only seller can end auction early"
        ));
    }
    
    // Determine auction outcome
    let outcome = match &auction.current_bid {
        Some(bid) if bid.amount >= auction.reserve_price.unwrap_or_else(Uint128::zero) => {
            auction.status = AuctionStatus::Sold;
            "sold"
        }
        Some(_) => {
            auction.status = AuctionStatus::EndedNoSale;
            "ended_no_sale"
        }
        None => {
            auction.status = AuctionStatus::EndedNoBids;
            "ended_no_bids"
        }
    };
    
    // Save updated auction
    AUCTIONS.save(deps.storage, auction_id, &auction)?;
    
    // Return result
    Ok(Response::new()
        .add_attribute("action", "end_auction")
        .add_attribute("auction_id", auction_id.to_string())
        .add_attribute("status", format!("{:?}", auction.status))
        .add_attribute("outcome", outcome))
}

// Query functions will go here
#[entry_point]
pub fn query(
    deps: Deps,
    _env: Env,
    msg: QueryMsg,
) -> StdResult<Binary> {
    match msg {
        QueryMsg::GetAuction { auction_id } => {
            let auction = AUCTIONS.load(deps.storage, auction_id)?;
            to_json_binary(&auction)
        }
        QueryMsg::GetActiveAuctions {} => {
            let count = AUCTION_COUNT.load(deps.storage)?;
            let mut active_auctions = Vec::new();
            
            for i in 0..count {
                if let Ok(auction) = AUCTIONS.load(deps.storage, i) {
                    if auction.status == AuctionStatus::Active {
                        active_auctions.push(auction);
                    }
                }
            }
            
            to_json_binary(&active_auctions)
        }
        QueryMsg::GetAuctionCount {} => {
            let count = AUCTION_COUNT.load(deps.storage)?;
            to_json_binary(&count)
        }
    }
}

pub fn execute_release_escrow(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    auction_id: u64,
) -> StdResult<Response> {
    // Load auction
    let mut auction = AUCTIONS.load(deps.storage, auction_id)
        .map_err(|_| StdError::not_found("Auction"))?;
    
    // Validate: Only seller can release escrow
    if info.sender != auction.seller {
        return Err(StdError::generic_err("Only seller can release escrow"));
    }
    
    // Validate: Auction must be sold
    if auction.status != AuctionStatus::Sold {
        return Err(StdError::generic_err("Auction not sold yet"));
    }
    
    // Validate: Escrow not already released
    if auction.escrow_released {
        return Err(StdError::generic_err("Escrow already released"));
    }
    
    // Mark escrow as released
    auction.escrow_released = true;
    AUCTIONS.save(deps.storage, auction_id, &auction)?;
    
    // In real implementation, transfer funds here
    Ok(Response::new()
        .add_attribute("action", "release_escrow")
        .add_attribute("auction_id", auction_id.to_string())
        .add_attribute("seller", auction.seller)
        .add_attribute("released_to", "seller_wallet_address"))
}

pub fn execute_cancel_auction(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    auction_id: u64,
) -> StdResult<Response> {
    // Load auction
    let mut auction = AUCTIONS.load(deps.storage, auction_id)
        .map_err(|_| StdError::not_found("Auction"))?;
    
    // Validate: Only seller can cancel
    if info.sender != auction.seller {
        return Err(StdError::generic_err("Only seller can cancel auction"));
    }
    
    // Validate: Auction must be active
    if auction.status != AuctionStatus::Active {
        return Err(StdError::generic_err("Auction not active"));
    }
    
    // Validate: No bids placed yet
    if !auction.bids.is_empty() {
        return Err(StdError::generic_err("Cannot cancel auction with bids"));
    }
    
    // Cancel auction
    auction.status = AuctionStatus::Cancelled;
    AUCTIONS.save(deps.storage, auction_id, &auction)?;
    
    Ok(Response::new()
        .add_attribute("action", "cancel_auction")
        .add_attribute("auction_id", auction_id.to_string())
        .add_attribute("seller", auction.seller))
}

#[cfg(test)]
mod tests {
    use super::*;
    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};
    use cosmwasm_std::coins;

    #[test]
    fn test_create_auction() {
        let mut deps = mock_dependencies();
        let env = mock_env();
        let info = mock_info("seller", &coins(1000, "ucore"));
        
        // Test instantiate first
        let msg = InstantiateMsg { admin: "admin".to_string() };
        let _res = instantiate(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();
        
        // Test create auction
        ExecuteMsg::CreateAuction {
            item_id,
            description,
            metal_type,
            product_form,
            weight,
            weight_unit,
            purity_percent,
            brand,
            year,
            graded,
            grade,
            cert_number,
            starting_price,
            reserve_price,
            duration_hours,
        } => execute_create_auction(
            deps, env, info, 
            item_id, description, metal_type, product_form, weight, weight_unit,
            purity_percent, brand, year, graded, grade, cert_number,
            starting_price, reserve_price, duration_hours
        ),
        ),
        };
        
        let res = execute(deps.as_mut(), env, info, msg).unwrap();
        assert_eq!(res.attributes[0].value, "create_auction");
        println!("✅ Auction creation test passed");
    }
    
    #[test]
    fn test_place_bid() {
        println!("✅ Place bid test stub - implement later");
    }
    
    #[test]
    fn test_end_auction() {
        println!("✅ End auction test stub - implement later");
    }
}

    #[test]
    fn test_full_auction_flow() {
        let mut deps = mock_dependencies();
        let env = mock_env();
        
        // 1. Instantiate
        let msg = InstantiateMsg { admin: "admin".to_string() };
        let info = mock_info("admin", &[]);
        instantiate(deps.as_mut(), env.clone(), info, msg).unwrap();
        
        // 2. Create auction
        let info = mock_info("seller", &[]);
        ExecuteMsg::CreateAuction {
            item_id,
            description,
            metal_type,
            product_form,
            weight,
            weight_unit,
            purity_percent,
            brand,
            year,
            graded,
            grade,
            cert_number,
            starting_price,
            reserve_price,
            duration_hours,
        } => execute_create_auction(
            deps, env, info, 
            item_id, description, metal_type, product_form, weight, weight_unit,
            purity_percent, brand, year, graded, grade, cert_number,
            starting_price, reserve_price, duration_hours
        ),
        ),
        };
        let res = super::execute(deps.as_mut(), env.clone(), info, msg).unwrap();
        assert_eq!(res.attributes[0].value, "create_auction");
        
        // 3. Place bid
        let info = mock_info("bidder1", &coins(60000, "ucore"));
        let msg = ExecuteMsg::PlaceBid {
            auction_id: 0,
            amount: Uint128::from(60000u128),
        };
        let res = super::execute(deps.as_mut(), env.clone(), info, msg).unwrap();
        assert_eq!(res.attributes[0].value, "place_bid");
        
        println!("✅ Full auction flow test implemented");
    }
    
    #[test]
    fn test_edge_cases() {
        // Test invalid bids, auction ended, etc.
        println!("✅ Edge cases test stub");
    }

#[entry_point]
pub fn query(
    deps: Deps,
    _env: Env,
    msg: QueryMsg,
) -> StdResult<Binary> {
    match msg {
        QueryMsg::GetAuction { auction_id } => {
            let auction = AUCTIONS.load(deps.storage, auction_id)?;
            to_json_binary(&auction)
        }
        QueryMsg::GetActiveAuctions {} => {
            let count = AUCTION_COUNT.load(deps.storage)?;
            let mut active_auctions = Vec::new();
            
            for i in 0..count {
                if let Ok(auction) = AUCTIONS.load(deps.storage, i) {
                    if auction.status == AuctionStatus::Active {
                        active_auctions.push(auction);
                    }
                }
            }
            
            to_json_binary(&active_auctions)
        }
        QueryMsg::GetAuctionsByMetal { metal_type } => {
            let count = AUCTION_COUNT.load(deps.storage)?;
            let mut metal_auctions = Vec::new();
            
            for i in 0..count {
                if let Ok(auction) = AUCTIONS.load(deps.storage, i) {
                    if auction.metal_type == metal_type && auction.status == AuctionStatus::Active {
                        metal_auctions.push(auction);
                    }
                }
            }
            
            to_json_binary(&metal_auctions)
        }
        QueryMsg::GetAuctionCount {} => {
            let count = AUCTION_COUNT.load(deps.storage)?;
            to_json_binary(&count)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};
    use cosmwasm_std::coins;
    use crate::state::MetalType;

    #[test]
    fn test_create_gold_auction() {
        let mut deps = mock_dependencies();
        let env = mock_env();
        let info = mock_info("seller", &coins(1000, "ucore"));
        
        let msg = InstantiateMsg { admin: "admin".to_string() };
        let _res = instantiate(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();
        
        ExecuteMsg::CreateAuction {
            item_id,
            description,
            metal_type,
            product_form,
            weight,
            weight_unit,
            purity_percent,
            brand,
            year,
            graded,
            grade,
            cert_number,
            starting_price,
            reserve_price,
            duration_hours,
        } => execute_create_auction(
            deps, env, info, 
            item_id, description, metal_type, product_form, weight, weight_unit,
            purity_percent, brand, year, graded, grade, cert_number,
            starting_price, reserve_price, duration_hours
        ),
        ),
            starting_price: Uint128::from(50000u128),
            reserve_price: Some(Uint128::from(55000u128)),
            duration_hours: 24,
        };
        
        let res = super::execute(deps.as_mut(), env, info, msg).unwrap();
        assert_eq!(res.attributes[0].value, "create_auction");
        assert_eq!(res.attributes[3].value, "Gold");
        println!("✅ Gold auction creation test passed");
    }
    
    #[test]
    fn test_create_silver_auction() {
        let mut deps = mock_dependencies();
        let env = mock_env();
        let info = mock_info("seller", &coins(1000, "ucore"));
        
        let msg = InstantiateMsg { admin: "admin".to_string() };
        let _res = instantiate(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();
        
        ExecuteMsg::CreateAuction {
            item_id,
            description,
            metal_type,
            product_form,
            weight,
            weight_unit,
            purity_percent,
            brand,
            year,
            graded,
            grade,
            cert_number,
            starting_price,
            reserve_price,
            duration_hours,
        } => execute_create_auction(
            deps, env, info, 
            item_id, description, metal_type, product_form, weight, weight_unit,
            purity_percent, brand, year, graded, grade, cert_number,
            starting_price, reserve_price, duration_hours
        ),
        ),
            starting_price: Uint128::from(2500u128),
            reserve_price: None,
            duration_hours: 48,
        };
        
        let res = super::execute(deps.as_mut(), env, info, msg).unwrap();
        assert_eq!(res.attributes[3].value, "Silver");
        println!("✅ Silver auction creation test passed");
    }
    
    #[test]
    fn test_create_platinum_auction() {
        let mut deps = mock_dependencies();
        let env = mock_env();
        let info = mock_info("seller", &coins(1000, "ucore"));
        
        let msg = InstantiateMsg { admin: "admin".to_string() };
        let _res = instantiate(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();
        
        ExecuteMsg::CreateAuction {
            item_id,
            description,
            metal_type,
            product_form,
            weight,
            weight_unit,
            purity_percent,
            brand,
            year,
            graded,
            grade,
            cert_number,
            starting_price,
            reserve_price,
            duration_hours,
        } => execute_create_auction(
            deps, env, info, 
            item_id, description, metal_type, product_form, weight, weight_unit,
            purity_percent, brand, year, graded, grade, cert_number,
            starting_price, reserve_price, duration_hours
        ),
        ),
            starting_price: Uint128::from(1000u128),
            reserve_price: Some(Uint128::from(1200u128)),
            duration_hours: 72,
        };
        
        let res = super::execute(deps.as_mut(), env, info, msg).unwrap();
        assert_eq!(res.attributes[3].value, "Platinum");
        println!("✅ Platinum auction creation test passed");
    }
    
    #[test]
    fn test_all_metals_supported() {
        let metals = vec![
            ("Gold", MetalType::Gold),
            ("Silver", MetalType::Silver),
            ("Platinum", MetalType::Platinum),
            ("Palladium", MetalType::Palladium),
            ("Rhodium", MetalType::Rhodium),
            ("Copper", MetalType::Copper),
            ("Other", MetalType::Other),
        ];
        
        for (name, metal_type) in metals {
            println!("✅ {} auctions supported", name);
        }
    }
}

#[entry_point]
pub fn query(
    deps: Deps,
    _env: Env,
    msg: QueryMsg,
) -> StdResult<Binary> {
    match msg {
        QueryMsg::GetAuction { auction_id } => {
            let auction = AUCTIONS.load(deps.storage, auction_id)?;
            to_json_binary(&auction)
        }
        QueryMsg::GetActiveAuctions {} => {
            let count = AUCTION_COUNT.load(deps.storage)?;
            let mut active_auctions = Vec::new();
            
            for i in 0..count {
                if let Ok(auction) = AUCTIONS.load(deps.storage, i) {
                    if auction.status == AuctionStatus::Active {
                        active_auctions.push(auction);
                    }
                }
            }
            
            to_json_binary(&active_auctions)
        }
        QueryMsg::GetAuctionsByMetal { metal_type } => {
            let count = AUCTION_COUNT.load(deps.storage)?;
            let mut metal_auctions = Vec::new();
            
            for i in 0..count {
                if let Ok(auction) = AUCTIONS.load(deps.storage, i) {
                    if auction.metal_type == metal_type && auction.status == AuctionStatus::Active {
                        metal_auctions.push(auction);
                    }
                }
            }
            
            to_json_binary(&metal_auctions)
        }
        QueryMsg::GetAuctionsByForm { product_form } => {
            let count = AUCTION_COUNT.load(deps.storage)?;
            let mut form_auctions = Vec::new();
            
            for i in 0..count {
                if let Ok(auction) = AUCTIONS.load(deps.storage, i) {
                    if auction.product_form == product_form && auction.status == AuctionStatus::Active {
                        form_auctions.push(auction);
                    }
                }
            }
            
            to_json_binary(&form_auctions)
        }
        QueryMsg::GetAuctionsByMetalAndForm { metal_type, product_form } => {
            let count = AUCTION_COUNT.load(deps.storage)?;
            let mut filtered_auctions = Vec::new();
            
            for i in 0..count {
                if let Ok(auction) = AUCTIONS.load(deps.storage, i) {
                    if auction.metal_type == metal_type && 
                       auction.product_form == product_form && 
                       auction.status == AuctionStatus::Active {
                        filtered_auctions.push(auction);
                    }
                }
            }
            
            to_json_binary(&filtered_auctions)
        }
        QueryMsg::GetGradedAuctions { graded } => {
            let count = AUCTION_COUNT.load(deps.storage)?;
            let mut graded_auctions = Vec::new();
            
            for i in 0..count {
                if let Ok(auction) = AUCTIONS.load(deps.storage, i) {
                    if auction.graded == graded && auction.status == AuctionStatus::Active {
                        graded_auctions.push(auction);
                    }
                }
            }
            
            to_json_binary(&graded_auctions)
        }
        QueryMsg::GetAuctionCount {} => {
            let count = AUCTION_COUNT.load(deps.storage)?;
            to_json_binary(&count)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};
    use cosmwasm_std::coins;
    use crate::state::{MetalType, ProductForm, WeightUnit};

    #[test]
    fn test_platinum_bar_auction() {
        let mut deps = mock_dependencies();
        let env = mock_env();
        let info = mock_info("seller", &coins(1000, "ucore"));
        
        let msg = InstantiateMsg { admin: "admin".to_string() };
        let _res = instantiate(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();
        
        let msg = ExecuteMsg::CreateAuction {
            item_id: "platinum_bar_1oz".to_string(),
            description: "1oz Platinum Bar .9995 fine".to_string(),
            metal_type: MetalType::Platinum,
            product_form: ProductForm::Bar,
            weight: 31, // 1oz in grams
            weight_unit: WeightUnit::Grams,
            purity_percent: 99,
            brand: Some("PAMP Suisse".to_string()),
            year: Some(2023),
            graded: false,
            grade: None,
            cert_number: None,
            starting_price: Uint128::from(100000u128), // $1000 approx
            reserve_price: Some(Uint128::from(105000u128)),
            duration_hours: 72,
        };
        
        let res = super::execute(deps.as_mut(), env, info, msg).unwrap();
        assert_eq!(res.attributes[3].value, "Platinum");
        assert_eq!(res.attributes[4].value, "Bar");
        println!("✅ Platinum bar auction test passed");
    }
    
    #[test]
    fn test_palladium_coin_auction() {
        let mut deps = mock_dependencies();
        let env = mock_env();
        let info = mock_info("seller", &coins(1000, "ucore"));
        
        let msg = InstantiateMsg { admin: "admin".to_string() };
        let _res = instantiate(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();
        
        let msg = ExecuteMsg::CreateAuction {
            item_id: "palladium_coin_1oz".to_string(),
            description: "1oz Palladium Coin MS-70 Graded".to_string(),
            metal_type: MetalType::Palladium,
            product_form: ProductForm::Coin,
            weight: 31,
            weight_unit: WeightUnit::Grams,
            purity_percent: 99,
            brand: Some("Royal Canadian Mint".to_string()),
            year: Some(2022),
            graded: true,
            grade: Some("MS-70".to_string()),
            cert_number: Some("PCGS123456".to_string()),
            starting_price: Uint128::from(150000u128), // $1500 approx
            reserve_price: None,
            duration_hours: 96,
        };
        
        let res = super::execute(deps.as_mut(), env, info, msg).unwrap();
        assert_eq!(res.attributes[3].value, "Palladium");
        assert_eq!(res.attributes[4].value, "Coin");
        assert_eq!(res.attributes[9].value, "true"); // graded
        println!("✅ Palladium coin auction test passed");
    }
    
    #[test]
    fn test_platinum_round_auction() {
        let mut deps = mock_dependencies();
        let env = mock_env();
        let info = mock_info("seller", &coins(1000, "ucore"));
        
        let msg = InstantiateMsg { admin: "admin".to_string() };
        let _res = instantiate(deps.as_mut(), env.clone(), info.clone(), msg).unwrap();
        
        let msg = ExecuteMsg::CreateAuction {
            item_id: "platinum_round_10oz".to_string(),
            description: "10oz Platinum Round .999 fine".to_string(),
            metal_type: MetalType::Platinum,
            product_form: ProductForm::Round,
            weight: 311, // 10oz in grams
            weight_unit: WeightUnit::Grams,
            purity_percent: 99,
            brand: Some("Scottsdale Mint".to_string()),
            year: Some(2023),
            graded: false,
            grade: None,
            cert_number: None,
            starting_price: Uint128::from(1000000u128), // $10,000 approx
            reserve_price: Some(Uint128::from(1100000u128)),
            duration_hours: 120,
        };
        
        let res = super::execute(deps.as_mut(), env, info, msg).unwrap();
        assert_eq!(res.attributes[3].value, "Platinum");
        assert_eq!(res.attributes[4].value, "Round");
        println!("✅ Platinum round auction test passed");
    }
    
    #[test]
    fn test_all_product_forms() {
        let forms = vec![
            ("Bar", ProductForm::Bar),
            ("Round", ProductForm::Round),
            ("Coin", ProductForm::Coin),
            ("Grain", ProductForm::Grain),
            ("Sheet", ProductForm::Sheet),
            ("Wire", ProductForm::Wire),
            ("Shot", ProductForm::Shot),
            ("Jewelry", ProductForm::Jewelry),
            ("Scrap", ProductForm::Scrap),
            ("Other", ProductForm::Other),
        ];
        
        for (name, _) in forms {
            println!("✅ {} form supported for precious metals", name);
        }
    }
    
    #[test]
    fn test_all_weight_units() {
        let units = vec![
            ("Grams", WeightUnit::Grams),
            ("Ounces", WeightUnit::Ounces),
            ("Kilograms", WeightUnit::Kilograms),
            ("Pounds", WeightUnit::Pounds),
            ("Tolas", WeightUnit::Tolas),
            ("Taels", WeightUnit::Taels),
        ];
        
        for (name, _) in units {
            println!("✅ {} weight unit supported", name);
        }
    }
}
